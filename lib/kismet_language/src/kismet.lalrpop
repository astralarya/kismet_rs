use crate::ast::Node;
use crate::lexer::LexerError;
use crate::token::Token;
use crate::types::{Integer, Span};

grammar<'input>;

pub Kismet: Node<'input> = {
  stmts,
  => Node::stmts((Span(0..0), vec![]))
}

stmts: Node<'input> = {
  JoinFilter<DELIM, stmt> => Node::stmts(<>),
}

stmt: Node<'input> = {
  expr,
}

exprs: (Span, Vec<Node<'input>>) = <JoinPlus<COMMA, expr>>;

expr: Node<'input> = {
  or_test,
}

or_test = Infix<OR, and_test>;
and_test = Infix<AND, not_test>;

not_test: Node<'input> = {
  NOT not_test => Node::unary(<>),
  c_expr,
}

c_expr = Infix<EQS, a_expr>;
a_expr = Infix<ADDS, m_expr>;
m_expr = Infix<MULS, u_expr>;

u_expr: Node<'input> = {
  ADDS primary => Node::unary(<>),
  power,
}

power: Node<'input> = {
  primary POW u_expr => Node::op(<>),
  primary,
}

primary: Node<'input> = {
  primary DIE atom => Node::op(<>),
  DIE atom => Node::unary(<>),
  atom,
}

atom: Node<'input> = {
  enclosure,
  identifier,
  literal,
}

enclosure: Node<'input> = {
  parenth_form,
  list_display,
  <l:LBRACE> <v:stmts> <r:RBRACE> => Node::enclosure(<>),
}

parenth_form: Node<'input> = {
  <l:LPAREN> <e:exprs> <r:RPAREN> => Node::tuple((l.span() + r.span(), e.1)),
  <l:LPAREN> <e:expr> <r:RPAREN> => Node::enclosure(<>),
  <l:LPAREN> <r:RPAREN> => Node::tuple((l.span() + r.span(),vec![])),
}

list_display: Node<'input> = {
  LBRACKET <exprs> RBRACKET => Node::vector(<>),
  LBRACKET comprehension RBRACKET => Node::enclosure(<>),
}

comprehension: Node<'input> = {
  expr comp_for+ => Node::comprehension(<>)
}

comp_for: Node<'input> = {
  FOR <target_list> IN <or_test> <(IF <or_test>)?> => Node::comp_for(<>)
}

target: Node<'input> = {
  identifier,
  LPAREN target_list RPAREN => Node::enclosure(<>),
  LBRACKET target_list RBRACKET => Node::enclosure(<>),
}

target_list: Node<'input> = {
  Join<COMMA, target> => Node::target_list(<>),
}

identifier: Node<'input> = {
  ID => Node::id(<>),
}

literal: Node<'input> = {
  STRING => Node::string(<>),
  INT => Node::integer(<>),
}

// Tokens

EQS: Token<'input> = {
  EQ,
  NE,
  LT,
  LE,
  GT,
  GE,
}

ADDS: Token<'input> = {
  ADD,
  SUB,
}

MULS: Token<'input> = {
  MOD,
  MUL,
  DIV,
}

extern {
  type Location = usize;
  type Error = LexerError;

  enum Token<'input> {
    DELIM => Token::DELIM(_),
    COMMA => Token::COMMA(_),
    FOR => Token::FOR(_),
    IN => Token::IN(_),
    IF => Token::IF(_),
    OR => Token::OR(_),
    AND => Token::AND(_),
    NOT => Token::NOT(_),
    EQ => Token::EQ(_),
    NE => Token::NE(_),
    LT => Token::LT(_),
    LE => Token::LE(_),
    GT => Token::GT(_),
    GE => Token::GE(_),
    ADD => Token::ADD(_),
    SUB => Token::SUB(_),
    MOD => Token::MOD(_),
    MUL => Token::MUL(_),
    DIV => Token::DIV(_),
    POW => Token::POW(_),
    DIE => Token::DIE(_),
    LPAREN => Token::LPAREN(_),
    RPAREN => Token::RPAREN(_),
    LBRACKET => Token::LBRACKET(_),
    RBRACKET => Token::RBRACKET(_),
    LBRACE => Token::LBRACE(_),
    RBRACE => Token::RBRACE(_),
    STRING => Token::String(<(Span, String)>),
    INT => Token::Integer(<(Span, Integer)>),
    ID => Token::Id(<(Span, &'input str)>),
  }
}

// Macros

Infix<Op, Next>: Node<'input> = {
  <l:Infix<Op, Next>> <o:Op> <r:Next> => Node::op(<>),
  Next
}

Join<Delim, Child>: (Span, Vec<Node<'input>>) = {
  <v:JoinInner<Delim, Child>> <d:Delim?> => match d {
    None => v,
    Some(d) => {
      (v.0 + d.span(), v.1)
    }
  },
}

JoinInner<Delim, Child>: (Span, Vec<Node<'input>>) = {
  <mut v:JoinInner<Delim, Child>> Delim <c:Child> => {
    (v.0 + c.span.clone(), {v.1.push(c); v.1})
  },
  Child => (<>.span.clone(), vec![<>])
}

JoinPlus<Delim, Child>: (Span, Vec<Node<'input>>) = {
  <mut v:JoinPlusInner<Delim, Child>> <e:Child?> => match e {
    None => v,
    Some(e) => {
      (v.0 + e.span.clone(), {v.1.push(e); v.1})
    }
  },
}

JoinPlusInner<Delim, Child>: (Span, Vec<Node<'input>>) = {
  <mut v:JoinPlusInner<Delim, Child>> <c:Child> <d:Delim> => {
    (v.0 + d.span(), {v.1.push(c); v.1})
  },
  <c:Child> <d:Delim>=> (c.span.clone() + d.span(), vec![c])
}

JoinFilter<Delim, Child>: (Span, Vec<Node<'input>>) = {
  <l:Delim*> <v:JoinFilterInner<Delim, Child>> <r:Delim*> => match (r.len(), l.len()) {
    (0, 0) => v,
    (_, 0) => (l[0].span() + v.0, v.1),
    (0, _) => (v.0 + r[r.len()-1].span(), v.1),
    (_, _) => (l[0].span() + r[r.len()-1].span(), v.1),
  },
}

JoinFilterInner<Delim, Child>: (Span, Vec<Node<'input>>) = {
  <mut v:JoinFilterInner<Delim, Child>> Delim+ <c:Child> => {
    (v.0 + c.span.clone(), {v.1.push(c); v.1})
  },
  Child => (<>.span.clone(), vec![<>])
}