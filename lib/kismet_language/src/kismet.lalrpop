use std::str::FromStr;

use lalrpop_util::ParseError;

use super::ast::{Node, Sym};

grammar;

pub Kismet: Node = {
  Expr
}

Expr: Node = {
  <l:Expr> <o:OpAdd> <r:Factor> => Node::Op(Box::new(l), o, Box::new(r)),
  Factor,
}

Factor: Node = {
  <l:Factor> <o:OpMul> <r:Atom> => Node::Op(Box::new(l), o, Box::new(r)),
  Atom,
}

Atom: Node = {
  <l:Atom> <o:OpPow> <r:Die> => Node::Op(Box::new(l), o, Box::new(r)),
  <o:OpAdd> <r:Die> => Node::Unary(o, Box::new(r)),
  Die,
}

Die: Node = {
  <l:Die> <o:OpDie> <r:Term> => Node::Op(Box::new(l), o, Box::new(r)),
  <o:OpDie> <r:Term> => Node::Unary(o, Box::new(r)),
  Term,
}

Term: Node = {
  "(" <e:Expr> ")" => Node::Paren(Box::new(e)),
  Num,
}

//

Num: Node = {
  <s:r"[0-9]+"> =>? i32::from_str(s)
    .map(|r| Node::Int(r))
    .map_err(|_| ParseError::User{error: "Integer out of range"})
}

OpAdd: Sym = {
  "+" => Sym::Add,
  "-" => Sym::Sub,
}

OpMul: Sym = {
  "%" => Sym::Mod,
  "*" => Sym::Mul,
  "/" => Sym::Sub,
}

OpPow: Sym = {
  "^" => Sym::Pow,
}

OpDie: Sym = {
  "d" => Sym::Die,
}