use crate::ast::*;
use crate::lexer::LexerError;
use crate::token::{NumberKind, Token, TokenKind};
use crate::types::{Integer, Float, Span};

grammar<'input>;

pub Kismet = {
  stmts,
  => Node::stmts((Span(0..0), vec![]))
}

stmts: Node<Expr<'input>> = {
  JoinFilter<DELIM, stmt> => Node::stmts(<>),
}

stmt = {
  expression,
}

expression_list = <JoinPlus<COMMA, expression>>;

expression = {
  walrus_expression,
}

walrus_expression = {
  or_test,
}

or_test = Infix<OR, and_test>;
and_test = Infix<AND, not_test>;

not_test = {
  NOT not_test => Node::unary(<>),
  c_expr,
}

c_expr = Infix<EQS, a_expr>;
a_expr = Infix<ADDS, m_expr>;
m_expr = Infix<MULS, u_expr>;

u_expr = {
  ADDS primary => Node::unary(<>),
  power,
}

power = Infix<POW, coefficient>;

coefficient = {
  numeric_literal die => Node::coefficient(<>),
  enclosure die => Node::coefficient(<>),
  die,
}

die = {
  DIE primary => Node::die(<>),
  primary,
}

primary = {
  atom,
}

atom: Node<Expr<'input>> = {
  enclosure => Node::expr_atom(<>),
  identifier => Node::expr_atom(<>),
  literal => Node::expr_atom(<>),
}

enclosure = {
  parenth_form,
  list_display,
  dict_display,
  <l:LBRACE> <v:stmts> <r:RBRACE> => Node::atom(l.span + r.span, Atom::Statements(v)),
}

parenth_form: Node<Atom<'input>> = {
  <l:LPAREN> <e:expression_list> <r:RPAREN> => Node::tuple((l.span + r.span, e.1)),
  <l:LPAREN> <v:expression> <r:RPAREN> => Node::atom(l.span + r.span, Atom::Expression(v)),
  <l:LPAREN> <r:RPAREN> => Node::tuple((l.span + r.span,vec![])),
}

list_display: Node<Atom<'input>> = {
  <l:LBRACKET> <v:spread_list> <r:RBRACKET> =>
    Node::list_display((l.span + r.span, v.1)),
  <l:LBRACKET> <v:list_comprehension> <r:RBRACKET> =>
    Node::atom(l.span + r.span, v),
  <l:LBRACKET> <r:RBRACKET> => Node::list_display((l.span + r.span,vec![])),
}

list_comprehension: Atom<'input> = {
  <e:walrus_expression> <mut iter:comp_for> =>
    Atom::ListComprehension{value: e, iter: {iter.reverse(); iter}}
}

dict_display: Node<Atom<'input>> = {
  <l:LBRACE> <v:key_datum_list> <r:RBRACE> =>
    Node::dict_display((l.span + r.span, v.1)),
  <l:LBRACE> <v:dict_comprehension> <r:RBRACE> =>
    Node::atom(l.span + r.span, v),
  <l:LBRACE> <r:RBRACE> => Node::dict_display((l.span + r.span,vec![])),
}

dict_comprehension: Atom<'input> = {
  <key:expression> COLON <value:expression> <mut iter:comp_for> =>
    Atom::DictComprehension{key, value, iter: {iter.reverse(); iter}},
}

spread_list = Join<COMMA, spread_item>;
spread_item: Node<SpreadItem<'input>> = {
  walrus_expression => Node::new(<>.span, SpreadItem::Expr(*<>.kind)),
  <t:SPREAD> <n:a_expr> => Node::new(t.span + n.span.clone(), SpreadItem::Spread(n)),
}

key_datum_list = Join<COMMA, key_datum>;
key_datum: Node<KeyDatum<'input>> = {
  <l:expression> COLON <r:expression> =>
    Node::new(l.span.clone() + r.span.clone(), KeyDatum::KeyDatum(l, r)),
  <o:SPREAD> <e:a_expr> =>
    Node::new(o.span + e.span.clone(), KeyDatum::Spread(e)),
}

comp_for: Vec<Node<CompIter<'input>>> = {
  <l:FOR> <target:target_list> IN <expr:or_test> <iter:comp_iter?> => {
    let node = Node::new(l.span + expr.span.clone(), CompIter::For{target: target.1, expr});
    match iter {
      Some(mut v) => {v.push(node); v},
      None => vec![node],
    }
  }
}

comp_iter = {
  comp_for,
  comp_if,
}

comp_if: Vec<Node<CompIter<'input>>> = {
  <l:IF> <expr:or_test> <iter:comp_iter?> => {
    let node = Node::new(l.span + expr.span.clone(), CompIter::If(expr));
    match iter {
      Some(mut v) => {v.push(node); v},
      None => vec![node],
    }
  }
}

target: Node<Target<'input>> = {
  ID => Node::target(<>.0, Target::Id(<>.1)),
  <l:LPAREN> <v:target_list> <r:RPAREN> => Node::target(l.span + r.span, Target::TargetTuple(v.1)),
  <l:LBRACKET> <v:target_list> <r:RBRACKET> => Node::target(l.span + r.span, Target::TargetList(v.1)),
}

target_list = Join<COMMA, target>;

identifier: Node<Atom<'input>> = {
  ID => Node::id(<>),
}

literal = {
  STRING => Node::string(<>),
  numeric_literal,
}

numeric_literal: Node<Atom<'input>> = {
  FLOAT => Node::float(<>),
  INT => Node::integer(<>),
}

// Tokens

EQS = {
  EQ,
  NE,
  LT,
  LE,
  GT,
  GE,
}

ADDS = {
  ADD,
  SUB,
}

MULS = {
  MOD,
  MUL,
  DIV,
}

extern {
  type Location = usize;
  type Error = LexerError;

  enum Token<'input> {
    DELIM => Token { kind: TokenKind::DELIM, .. },
    COMMA => Token { kind: TokenKind::COMMA, .. },
    COLON => Token { kind: TokenKind::COLON, .. },
    SPREAD => Token { kind: TokenKind::SPREAD, .. },
    FOR => Token { kind: TokenKind::FOR, .. },
    IN => Token { kind: TokenKind::IN, .. },
    IF => Token { kind: TokenKind::IF, .. },
    OR => Token { kind: TokenKind::OR, .. },
    AND => Token { kind: TokenKind::AND, .. },
    NOT => Token { kind: TokenKind::NOT, .. },
    EQ => Token { kind: TokenKind::EQ, .. },
    NE => Token { kind: TokenKind::NE, .. },
    LT => Token { kind: TokenKind::LT, .. },
    LE => Token { kind: TokenKind::LE, .. },
    GT => Token { kind: TokenKind::GT, .. },
    GE => Token { kind: TokenKind::GE, .. },
    ADD => Token { kind: TokenKind::ADD, .. },
    SUB => Token { kind: TokenKind::SUB, .. },
    MOD => Token { kind: TokenKind::MOD, .. },
    MUL => Token { kind: TokenKind::MUL, .. },
    DIV => Token { kind: TokenKind::DIV, .. },
    POW => Token { kind: TokenKind::POW, .. },
    DIE => Token { kind: TokenKind::DIE, .. },
    LPAREN => Token { kind: TokenKind::LPAREN, .. },
    RPAREN => Token { kind: TokenKind::RPAREN, .. },
    LBRACKET => Token { kind: TokenKind::LBRACKET, .. },
    RBRACKET => Token { kind: TokenKind::RBRACKET, .. },
    LBRACE => Token { kind: TokenKind::LBRACE, .. },
    RBRACE => Token { kind: TokenKind::RBRACE, .. },
    STRING => Token {span: <Span>, kind: TokenKind::String(<String>) },
    INT => Token {span: <Span>, kind: TokenKind::Number(NumberKind::Integer(<Integer>)) },
    FLOAT => Token {span: <Span>, kind: TokenKind::Number(NumberKind::Float(<Float>)) },
    ID => Token {span: <Span>, kind: TokenKind::Id(<&'input str>) },
  }
}

// Macros

Infix<Op, Next> = {
  <l:Infix<Op, Next>> <o:Op> <r:Next> => Node::op(<>),
  Next
}

Join<Delim, Child>: (Span, Vec<Child>) = {
  <v:JoinInner<Delim, Child>> <d:Delim?> => match d {
    None => v,
    Some(d) => {
      (v.0 + d.span, v.1)
    }
  },
}

JoinInner<Delim, Child>: (Span, Vec<Child>) = {
  <mut v:JoinInner<Delim, Child>> Delim <c:Child> => {
    (v.0 + c.span.clone(), {v.1.push(c); v.1})
  },
  Child => (<>.span.clone(), vec![<>])
}

JoinPlus<Delim, Child>: (Span, Vec<Child>) = {
  <mut v:JoinPlusInner<Delim, Child>> <e:Child?> => match e {
    None => v,
    Some(e) => {
      (v.0 + e.span.clone(), {v.1.push(e); v.1})
    }
  },
}

JoinPlusInner<Delim, Child>: (Span, Vec<Child>) = {
  <mut v:JoinPlusInner<Delim, Child>> <c:Child> <d:Delim> => {
    (v.0 + d.span, {v.1.push(c); v.1})
  },
  <c:Child> <d:Delim>=> (c.span.clone() + d.span, vec![c])
}

JoinFilter<Delim, Child>: (Span, Vec<Child>) = {
  <l:Delim*> <v:JoinFilterInner<Delim, Child>> <r:Delim*> =>
    (
      v.0 + Span::add_option(
        Token::vec_to_span(&r),
        Token::vec_to_span(&l),
      ),
      v.1,
    )
}

JoinFilterInner<Delim, Child>: (Span, Vec<Child>) = {
  <mut v:JoinFilterInner<Delim, Child>> Delim+ <c:Child> => {
    (v.0 + c.span.clone(), {v.1.push(c); v.1})
  },
  Child => (<>.span.clone(), vec![<>])
}