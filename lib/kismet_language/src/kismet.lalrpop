use super::ast::Node;
use super::lexer::LexerError;
use super::token::Token;
use super::types::Integer;

grammar<'input>;

pub Kismet: Node<'input> = {
  stmts,
}

stmts: Node<'input> = {
  JoinFilter<DELIM, stmt> => Node::Stmts(<>),
}

stmt: Node<'input> = {
  expr,
}

exprs: Vec<Node<'input>> = <JoinPlus<COMMA, expr>>;

expr: Node<'input> = {
  or_test,
}

or_test = Infix<OR, and_test>;
and_test = Infix<AND, not_test>;

not_test: Node<'input> = {
  NOT not_test => Node::to_unary(<>),
  c_expr,
}

c_expr = Infix<EQS, a_expr>;
a_expr = Infix<ADDS, m_expr>;
m_expr = Infix<MULS, u_expr>;

u_expr: Node<'input> = {
  ADDS primary => Node::to_unary(<>),
  power,
}

power: Node<'input> = {
  primary POW u_expr => Node::to_op(<>),
  primary,
}

primary: Node<'input> = {
  primary DIE atom => Node::to_op(<>),
  DIE atom => Node::to_unary(<>),
  atom,
}

atom: Node<'input> = {
  enclosure,
  identifier,
  literal,
}

enclosure: Node<'input> = {
  parenth_form,
  list_display,
  <l:LBRACE> <v:stmts> <r:RBRACE> => Node::to_enclosure(<>),
}

parenth_form: Node<'input> = {
  LPAREN <exprs> RPAREN => Node::Tuple(<>),
  <l:LPAREN> <e:expr> <r:RPAREN> => Node::to_enclosure(<>),
  LPAREN RPAREN => Node::Tuple(vec![]),
}

list_display: Node<'input> = {
  LBRACKET <exprs> RBRACKET => Node::Vector(<>),
  LBRACKET comprehension RBRACKET => Node::to_enclosure(<>),
}

comprehension: Node<'input> = {
  expr comp_for+ => Node::to_comprehension(<>)
}

comp_for: Node<'input> = {
  FOR <target_list> IN <or_test> <(IF <or_test>)?> => Node::to_compfor(<>)
}

target: Node<'input> = {
  identifier,
  LPAREN target_list RPAREN => Node::to_enclosure(<>),
  LBRACKET target_list RBRACKET => Node::to_enclosure(<>),
}

target_list: Node<'input> = {
  Join<COMMA, target> => Node::TargetList(<>),
}

identifier: Node<'input> = {
  ID => Node::Id(<>),
}

literal: Node<'input> = {
  STRING => Node::String(<>),
  INT => Node::Integer(<>),
}

// Tokens

EQS: Token<'input> = {
  EQ,
  NE,
  LT,
  LE,
  GT,
  GE,
}

ADDS: Token<'input> = {
  ADD,
  SUB,
}

MULS: Token<'input> = {
  MOD,
  MUL,
  DIV,
}

extern {
  type Location = usize;
  type Error = LexerError;

  enum Token<'input> {
    DELIM => Token::DELIM,
    COMMA => Token::COMMA,
    FOR => Token::FOR,
    IN => Token::IN,
    IF => Token::IF,
    OR => Token::OR,
    AND => Token::AND,
    NOT => Token::NOT,
    EQ => Token::EQ,
    NE => Token::NE,
    LT => Token::LT,
    LE => Token::LE,
    GT => Token::GT,
    GE => Token::GE,
    ADD => Token::ADD,
    SUB => Token::SUB,
    MOD => Token::MOD,
    MUL => Token::MUL,
    DIV => Token::DIV,
    POW => Token::POW,
    DIE => Token::DIE,
    LPAREN => Token::LPAREN,
    RPAREN => Token::RPAREN,
    LBRACKET => Token::LBRACKET,
    RBRACKET => Token::RBRACKET,
    LBRACE => Token::LBRACE,
    RBRACE => Token::RBRACE,
    STRING => Token::String(<String>),
    INT => Token::Integer(<Integer>),
    ID => Token::Id(<&'input str>),
  }
}

// Macros

Join<Delim, Child>: Vec<Node<'input>> = {
  <mut v:(<Child> Delim)*> <e:Child?> => match e {
    None => v,
    Some(e) => { v.push(e); v }
  },
}


JoinPlus<Delim, Child>: Vec<Node<'input>> = {
  <mut v:(<Child> Delim)+> <e:Child?> => match e {
    None => v,
    Some(e) => { v.push(e); v }
  },
}

JoinFilter<Delim, Child>: Vec<Node<'input>> = {
  DELIM* <mut v:(<Child> Delim+)*> <e:Child?> => match e {
    None => v,
    Some(e) => { v.push(e); v }
  },
}


Infix<Op, Next>: Node<'input> = {
  <l:Infix<Op, Next>> <o:Op> <r:Next> => Node::to_op(<>),
  Next
}