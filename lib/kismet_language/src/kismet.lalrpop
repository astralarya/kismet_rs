use super::ast::Node;
use super::lexer::{Token, LexerError};

grammar<'input>;

extern {
  type Location = usize;
  type Error = LexerError;

  enum Token<'input> {
    OP_OR => Token::OR,
    OP_AND => Token::AND,
    OP_EQ => Token::EQ,
    OP_NE => Token::NE,
    OP_LT => Token::LT,
    OP_LE => Token::LE,
    OP_GT => Token::GT,
    OP_GE => Token::GE,
    OP_ADD => Token::ADD,
    OP_SUB => Token::SUB,
    OP_MOD => Token::MOD,
    OP_MUL => Token::MUL,
    OP_DIV => Token::DIV,
    OP_POW => Token::POW,
    OP_DIE => Token::DIE,
    LPAREN => Token::LPAREN,
    RPAREN => Token::RPAREN,
    INT => Token::Int(<i32>),
    ID => Token::Id(<&'input str>),
  }
}


pub Kismet: Node<'input> = {
  Expr
}

Expr: Node<'input> = {
  Disjunction,
}

Disjunction: Node<'input> = {
  <l:Disjunction> <o:OP_OR> <r:Conjunction> => Node::Op(Box::new(l), o, Box::new(r)),
  Conjunction,
}

Conjunction: Node<'input> = {
  <l:Conjunction> <o:OP_AND> <r:Comparison> => Node::Op(Box::new(l), o, Box::new(r)),
  Comparison,
}

Comparison: Node<'input> = {
  <l:Comparison> <o:OP_EQS> <r:Addition> => Node::Op(Box::new(l), o, Box::new(r)),
  Addition,
}

Addition: Node<'input> = {
  <l:Addition> <o:OP_ADDS> <r:Multiply> => Node::Op(Box::new(l), o, Box::new(r)),
  Multiply,
}

Multiply: Node<'input> = {
  <l:Multiply> <o:OP_MULS> <r:Unary> => Node::Op(Box::new(l), o, Box::new(r)),
  Unary,
}

Unary: Node<'input> = {
  <l:Unary> <o:OP_POW> <r:Die> => Node::Op(Box::new(l), o, Box::new(r)),
  <o:OP_ADDS> <r:Die> => Node::Unary(o, Box::new(r)),
  Die,
}

Die: Node<'input> = {
  <l:Die> <o:OP_DIE> <r:Atom> => Node::Op(Box::new(l), o, Box::new(r)),
  <o:OP_DIE> <r:Atom> => Node::Unary(o, Box::new(r)),
  Atom,
}

Atom: Node<'input> = {
  LPAREN <e:Expr> RPAREN => Node::Paren(Box::new(e)),
  Identifier,
  Literal,
}

Identifier: Node<'input> = {
  <s:ID> => Node::Id(s),
}

Literal: Node<'input> = {
  <i:INT> => Node::Int(i),
}

//

OP_EQS: Token<'input> = {
  OP_EQ,
  OP_NE,
  OP_LT,
  OP_LE,
  OP_GT,
  OP_GE,
}

OP_ADDS: Token<'input> = {
  OP_ADD,
  OP_SUB,
}

OP_MULS: Token<'input> = {
  OP_MOD,
  OP_MUL,
  OP_DIV,
}