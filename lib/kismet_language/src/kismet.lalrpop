use super::ast::Node;
use super::lexer::LexerError;
use super::token::Token;
use super::types::Integer;

grammar<'input>;

pub Kismet: Node<'input> = {
  <Stmts>,
}

Stmts: Node<'input> = {
  JoinFilter<DELIM, Stmt> => Node::Stmts(<>),
}

Stmt: Node<'input> = {
  Expr,
}

Exprs: Vec<Node<'input>> = <JoinPlus<COMMA, Expr>>;

Expr: Node<'input> = {
  Disjunction,
}

Disjunction = Infix<OR, Conjunction>;
Conjunction = Infix<AND, Comparison>;
Comparison = Infix<EQS, Addition>;
Addition = Infix<ADDS, Multiply>;
Multiply = Infix<MULS, Unary>;

Unary: Node<'input> = {
  <l:Unary> <o:POW> <r:Die> => Node::to_op(<>),
  <o:ADDS> <r:Die> => Node::to_unary(<>),
  Die,
}

Die: Node<'input> = {
  <l:Die> <o:DIE> <r:Atom> => Node::to_op(<>),
  <o:DIE> <r:Atom> => Node::to_unary(<>),
  Atom,
}

Atom: Node<'input> = {
  Enclosure,
  Identifier,
  Literal,
}

Enclosure: Node<'input> = {
  ParenthForm,
  ListDisplay,
  <l:LBRACE> <v:Stmts> <r:RBRACE> => Node::to_enclosure(<>),
}

ParenthForm: Node<'input> = {
  LPAREN <Exprs> RPAREN => Node::Tuple(<>),
  <l:LPAREN> <e:Expr> <r:RPAREN> => Node::to_enclosure(<>),
  LPAREN RPAREN => Node::Tuple(vec![]),
}

ListDisplay: Node<'input> = {
  LBRACKET <Exprs> RBRACKET => Node::Vector(<>),
}

Identifier: Node<'input> = {
  ID => Node::Id(<>),
}

Literal: Node<'input> = {
  STRING => Node::String(<>),
  INT => Node::Integer(<>),
}

// Tokens

EQS: Token<'input> = {
  EQ,
  NE,
  LT,
  LE,
  GT,
  GE,
}

ADDS: Token<'input> = {
  ADD,
  SUB,
}

MULS: Token<'input> = {
  MOD,
  MUL,
  DIV,
}

extern {
  type Location = usize;
  type Error = LexerError;

  enum Token<'input> {
    DELIM => Token::DELIM,
    COMMA => Token::COMMA,
    OR => Token::OR,
    AND => Token::AND,
    EQ => Token::EQ,
    NE => Token::NE,
    LT => Token::LT,
    LE => Token::LE,
    GT => Token::GT,
    GE => Token::GE,
    ADD => Token::ADD,
    SUB => Token::SUB,
    MOD => Token::MOD,
    MUL => Token::MUL,
    DIV => Token::DIV,
    POW => Token::POW,
    DIE => Token::DIE,
    LPAREN => Token::LPAREN,
    RPAREN => Token::RPAREN,
    LBRACKET => Token::LBRACKET,
    RBRACKET => Token::RBRACKET,
    LBRACE => Token::LBRACE,
    RBRACE => Token::RBRACE,
    STRING => Token::String(<String>),
    INT => Token::Integer(<Integer>),
    ID => Token::Id(<&'input str>),
  }
}

// Macros

Join<Delim, Child>: Vec<Node<'input>> = {
  <mut v:(<Child> Delim)*> <e:Child?> => match e {
    None => v,
    Some(e) => { v.push(e); v }
  },
}


JoinPlus<Delim, Child>: Vec<Node<'input>> = {
  <mut v:(<Child> Delim)+> <e:Child?> => match e {
    None => v,
    Some(e) => { v.push(e); v }
  },
}

JoinFilter<Delim, Child>: Vec<Node<'input>> = {
  DELIM* <mut v:(<Child> Delim+)*> <e:Child?> => match e {
    None => v,
    Some(e) => { v.push(e); v }
  },
}


Infix<Op, Next>: Node<'input> = {
  <l:Infix<Op, Next>> <o:Op> <r:Next> => Node::to_op(<>),
  Next
}