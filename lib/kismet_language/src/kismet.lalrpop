use std::str::FromStr;

use lalrpop_util::ParseError;

use super::ast::{Node, Sym};

grammar;

pub Kismet: Node<'input> = {
  Expr
}

Expr: Node<'input> = {
  Disjunction,
}

Disjunction: Node<'input> = {
  <l:Disjunction> <o:OP_OR> <r:Conjunction> => Node::Op(Box::new(l), o, Box::new(r)),
  Conjunction,
}

Conjunction: Node<'input> = {
  <l:Conjunction> <o:OP_AND> <r:Comparison> => Node::Op(Box::new(l), o, Box::new(r)),
  Comparison,
}

Comparison: Node<'input> = {
  <l:Comparison> <o:OP_EQ> <r:Addition> => Node::Op(Box::new(l), o, Box::new(r)),
  Addition,
}

Addition: Node<'input> = {
  <l:Addition> <o:OP_ADD> <r:Multiply> => Node::Op(Box::new(l), o, Box::new(r)),
  Multiply,
}

Multiply: Node<'input> = {
  <l:Multiply> <o:OP_MUL> <r:Unary> => Node::Op(Box::new(l), o, Box::new(r)),
  Unary,
}

Unary: Node<'input> = {
  <l:Unary> <o:OP_POW> <r:Die> => Node::Op(Box::new(l), o, Box::new(r)),
  <o:OP_ADD> <r:Die> => Node::Unary(o, Box::new(r)),
  Die,
}

Die: Node<'input> = {
  <l:Die> <o:OP_DIE> <r:Atom> => Node::Op(Box::new(l), o, Box::new(r)),
  <o:OP_DIE> <r:Atom> => Node::Unary(o, Box::new(r)),
  Atom,
}

Atom: Node<'input> = {
  "(" <e:Expr> ")" => Node::Paren(Box::new(e)),
  Identifier,
  Literal,
}

Identifier: Node<'input> = {
  IDENTIFIER,
}

Literal: Node<'input> = {
  INT,
}

//

OP_OR: Sym = {
  r"(?i)or" => Sym::Or,
}

OP_AND: Sym = {
  r"(?i)and" => Sym::And,
}

OP_EQ: Sym = {
  "==" => Sym::Eq,
  "!=" => Sym::NotEq,
  "<" => Sym::Less,
  "<=" => Sym::LessEq,
  ">" => Sym::Greater,
  ">=" => Sym::GreaterEq,
}

OP_ADD: Sym = {
  "+" => Sym::Add,
  "-" => Sym::Sub,
}

OP_MUL: Sym = {
  "%" => Sym::Mod,
  "*" => Sym::Mul,
  "/" => Sym::Div,
}

OP_POW: Sym = {
  "^" => Sym::Pow,
}

OP_DIE: Sym = {
  "d" => Sym::Die,
}

INT: Node<'input> = {
  <s:r"[0-9]+"> =>? i32::from_str(s)
    .map(|r| Node::Int(r))
    .map_err(|_| ParseError::User{error: "Integer out of range"}),
}

IDENTIFIER: Node<'input> = {
  <s:r"\$[_a-zA-Z][_a-zA-Z0-9]*"> => Node::Id(s)
}
