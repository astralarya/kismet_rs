use super::ast::Node;
use super::lexer::{Token, LexerError};

grammar<'input>;

extern {
  type Location = usize;
  type Error = LexerError;

  enum Token<'input> {
    DELIM => Token::DELIM,
    OR => Token::OR,
    AND => Token::AND,
    EQ => Token::EQ,
    NE => Token::NE,
    LT => Token::LT,
    LE => Token::LE,
    GT => Token::GT,
    GE => Token::GE,
    ADD => Token::ADD,
    SUB => Token::SUB,
    MOD => Token::MOD,
    MUL => Token::MUL,
    DIV => Token::DIV,
    POW => Token::POW,
    DIE => Token::DIE,
    LPAREN => Token::LPAREN,
    RPAREN => Token::RPAREN,
    INT => Token::Int(<i32>),
    ID => Token::Id(<&'input str>),
  }
}


pub Kismet: Node<'input> = {
  Stmts
}

Delim<T>: Node<'input> = {
  <mut v:(<T> DELIM)*> <e:T?> => match e {
    None => Node::Stmts(v),
    Some(e) => {
      v.push(e);
      Node::Stmts(v)
    }
  }
}

Stmts = Delim<Stmt>;

Stmt: Node<'input> = {
  Expr,
}

Expr: Node<'input> = {
  Disjunction,
}

Disjunction: Node<'input> = {
  <l:Disjunction> <o:OR> <r:Conjunction> => Node::Op(Box::new(l), o, Box::new(r)),
  Conjunction,
}

Conjunction: Node<'input> = {
  <l:Conjunction> <o:AND> <r:Comparison> => Node::Op(Box::new(l), o, Box::new(r)),
  Comparison,
}

Comparison: Node<'input> = {
  <l:Comparison> <o:EQS> <r:Addition> => Node::Op(Box::new(l), o, Box::new(r)),
  Addition,
}

Addition: Node<'input> = {
  <l:Addition> <o:ADDS> <r:Multiply> => Node::Op(Box::new(l), o, Box::new(r)),
  Multiply,
}

Multiply: Node<'input> = {
  <l:Multiply> <o:MULS> <r:Unary> => Node::Op(Box::new(l), o, Box::new(r)),
  Unary,
}

Unary: Node<'input> = {
  <l:Unary> <o:POW> <r:Die> => Node::Op(Box::new(l), o, Box::new(r)),
  <o:ADDS> <r:Die> => Node::Unary(o, Box::new(r)),
  Die,
}

Die: Node<'input> = {
  <l:Die> <o:DIE> <r:Atom> => Node::Op(Box::new(l), o, Box::new(r)),
  <o:DIE> <r:Atom> => Node::Unary(o, Box::new(r)),
  Atom,
}

Atom: Node<'input> = {
  LPAREN <e:Expr> RPAREN => Node::Paren(Box::new(e)),
  Identifier,
  Literal,
}

Identifier: Node<'input> = {
  <s:ID> => Node::Id(s),
}

Literal: Node<'input> = {
  <i:INT> => Node::Int(i),
}

//

EQS: Token<'input> = {
  EQ,
  NE,
  LT,
  LE,
  GT,
  GE,
}

ADDS: Token<'input> = {
  ADD,
  SUB,
}

MULS: Token<'input> = {
  MOD,
  MUL,
  DIV,
}