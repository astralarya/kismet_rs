use crate::ast::{Atom, Expr, Node, SpreadItem};
use crate::lexer::LexerError;
use crate::token::{NumberKind, Token, TokenKind};
use crate::types::{Integer, Float, Span};

grammar<'input>;

pub Kismet: Node<Expr<'input>> = {
  stmts,
  => Node::stmts((Span(0..0), vec![]))
}

stmts: Node<Expr<'input>> = {
  JoinFilter<DELIM, stmt> => Node::stmts(<>),
}

stmt: Node<Expr<'input>> = {
  expression,
}

expression_list: (Span, Vec<Node<Expr<'input>>>) = <JoinPlus<COMMA, expression>>;

spread_list = <Join<COMMA, spread_item>>;
spread_item: Node<SpreadItem<'input>> = {
  walrus_expression => Node::spread((<>.span, SpreadItem::Expr(*<>.kind))),
  <t:SPREAD> <n:a_expr> => Node::spread((t.span + n.span.clone(), SpreadItem::Spread(n))),
}

expression: Node<Expr<'input>> = {
  walrus_expression,
}

walrus_expression: Node<Expr<'input>> = {
  or_test,
}

or_test = Infix<OR, and_test>;
and_test = Infix<AND, not_test>;

not_test: Node<Expr<'input>> = {
  NOT not_test => Node::unary(<>),
  c_expr,
}

c_expr = Infix<EQS, a_expr>;
a_expr = Infix<ADDS, m_expr>;
m_expr = Infix<MULS, u_expr>;

u_expr: Node<Expr<'input>> = {
  ADDS primary => Node::unary(<>),
  power,
}

power = Infix<POW, die>;

die: Node<Expr<'input>> = {
  primary DIE primary => Node::op(<>),
  DIE primary => Node::unary(<>),
  primary,
}

primary: Node<Expr<'input>> = {
  atom,
}

atom: Node<Expr<'input>> = {
  enclosure => Node::atom(<>),
  identifier => Node::atom(<>),
  literal => Node::atom(<>),
}

enclosure: Node<Atom<'input>> = {
  parenth_form,
  list_display,
  <l:LBRACE> <v:stmts> <r:RBRACE> => Node::enclosure(<>),
}

parenth_form: Node<Atom<'input>> = {
  <l:LPAREN> <e:expression_list> <r:RPAREN> => Node::tuple((l.span + r.span, e.1)),
  <l:LPAREN> <e:expression> <r:RPAREN> => Node::enclosure(<>),
  <l:LPAREN> <r:RPAREN> => Node::tuple((l.span + r.span,vec![])),
}

list_display: Node<Atom<'input>> = {
  LBRACKET <spread_list> RBRACKET => Node::list_display(<>),
  LBRACKET comprehension RBRACKET => Node::enclosure(<>),
}

comprehension: Node<Expr<'input>> = {
  expression comp_for+ => Node::comprehension(<>)
}

comp_for: Node<Expr<'input>> = {
  <l:FOR> <t:target_list> IN <n:or_test> <o:(IF <or_test>)?> =>
    Node::comp_for(l.span + n.span.clone() + o.as_ref().map_or(None, |x| Some(x.span.clone())), t, n, o)
}

target: Node<Atom<'input>> = {
  identifier,
  LPAREN target_list RPAREN => Node::enclosure(<>),
  LBRACKET target_list RBRACKET => Node::enclosure(<>),
}

target_list: Node<Expr<'input>> = {
  Join<COMMA, target> => Node::target_list(<>),
}

identifier: Node<Atom<'input>> = {
  ID => Node::id(<>),
}

literal: Node<Atom<'input>> = {
  STRING => Node::string(<>),
  FLOAT => Node::float(<>),
  INT => Node::integer(<>),
}

// Tokens

EQS: Token<'input> = {
  EQ,
  NE,
  LT,
  LE,
  GT,
  GE,
}

ADDS: Token<'input> = {
  ADD,
  SUB,
}

MULS: Token<'input> = {
  MOD,
  MUL,
  DIV,
}

extern {
  type Location = usize;
  type Error = LexerError;

  enum Token<'input> {
    DELIM => Token { kind: TokenKind::DELIM, .. },
    COMMA => Token { kind: TokenKind::COMMA, .. },
    SPREAD => Token { kind: TokenKind::SPREAD, .. },
    FOR => Token { kind: TokenKind::FOR, .. },
    IN => Token { kind: TokenKind::IN, .. },
    IF => Token { kind: TokenKind::IF, .. },
    OR => Token { kind: TokenKind::OR, .. },
    AND => Token { kind: TokenKind::AND, .. },
    NOT => Token { kind: TokenKind::NOT, .. },
    EQ => Token { kind: TokenKind::EQ, .. },
    NE => Token { kind: TokenKind::NE, .. },
    LT => Token { kind: TokenKind::LT, .. },
    LE => Token { kind: TokenKind::LE, .. },
    GT => Token { kind: TokenKind::GT, .. },
    GE => Token { kind: TokenKind::GE, .. },
    ADD => Token { kind: TokenKind::ADD, .. },
    SUB => Token { kind: TokenKind::SUB, .. },
    MOD => Token { kind: TokenKind::MOD, .. },
    MUL => Token { kind: TokenKind::MUL, .. },
    DIV => Token { kind: TokenKind::DIV, .. },
    POW => Token { kind: TokenKind::POW, .. },
    DIE => Token { kind: TokenKind::DIE, .. },
    LPAREN => Token { kind: TokenKind::LPAREN, .. },
    RPAREN => Token { kind: TokenKind::RPAREN, .. },
    LBRACKET => Token { kind: TokenKind::LBRACKET, .. },
    RBRACKET => Token { kind: TokenKind::RBRACKET, .. },
    LBRACE => Token { kind: TokenKind::LBRACE, .. },
    RBRACE => Token { kind: TokenKind::RBRACE, .. },
    STRING => Token {span: <Span>, kind: TokenKind::String(<String>) },
    INT => Token {span: <Span>, kind: TokenKind::Number(NumberKind::Integer(<Integer>)) },
    FLOAT => Token {span: <Span>, kind: TokenKind::Number(NumberKind::Float(<Float>)) },
    ID => Token {span: <Span>, kind: TokenKind::Id(<&'input str>) },
  }
}

// Macros

Infix<Op, Next>: Node<Expr<'input>> = {
  <l:Infix<Op, Next>> <o:Op> <r:Next> => Node::op(<>),
  Next
}

Join<Delim, Child>: (Span, Vec<Child>) = {
  <v:JoinInner<Delim, Child>> <d:Delim?> => match d {
    None => v,
    Some(d) => {
      (v.0 + d.span, v.1)
    }
  },
}

JoinInner<Delim, Child>: (Span, Vec<Child>) = {
  <mut v:JoinInner<Delim, Child>> Delim <c:Child> => {
    (v.0 + c.span.clone(), {v.1.push(c); v.1})
  },
  Child => (<>.span.clone(), vec![<>])
}

JoinPlus<Delim, Child>: (Span, Vec<Child>) = {
  <mut v:JoinPlusInner<Delim, Child>> <e:Child?> => match e {
    None => v,
    Some(e) => {
      (v.0 + e.span.clone(), {v.1.push(e); v.1})
    }
  },
}

JoinPlusInner<Delim, Child>: (Span, Vec<Child>) = {
  <mut v:JoinPlusInner<Delim, Child>> <c:Child> <d:Delim> => {
    (v.0 + d.span, {v.1.push(c); v.1})
  },
  <c:Child> <d:Delim>=> (c.span.clone() + d.span, vec![c])
}

JoinFilter<Delim, Child>: (Span, Vec<Child>) = {
  <l:Delim*> <v:JoinFilterInner<Delim, Child>> <r:Delim*> =>
    (
      v.0 + Span::add_option(
        Token::vec_to_span(&r),
        Token::vec_to_span(&l),
      ),
      v.1,
    )
}

JoinFilterInner<Delim, Child>: (Span, Vec<Child>) = {
  <mut v:JoinFilterInner<Delim, Child>> Delim+ <c:Child> => {
    (v.0 + c.span.clone(), {v.1.push(c); v.1})
  },
  Child => (<>.span.clone(), vec![<>])
}