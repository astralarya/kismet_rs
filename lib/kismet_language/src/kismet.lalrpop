use super::ast::Node;
use super::lexer::LexerError;
use super::token::Token;

grammar<'input>;

pub Kismet: Node<'input> = {
  Stmts
}

Delim<T>: Node<'input> = {
  <mut v:(<T> DELIM)*> <e:T?> => match e {
    None => Node::Stmts(v),
    Some(e) => {
      v.push(e);
      Node::Stmts(v)
    }
  }
}

Stmts = Delim<Stmt>;

Stmt: Node<'input> = {
  Expr,
}

Infix<Op, Next>: Node<'input> = {
  <l:Infix<Op, Next>> <o:Op> <r:Next> => Node::Op(Box::new(l), o, Box::new(r)),
  Next
}

Expr: Node<'input> = {
  Disjunction,
}

Disjunction = Infix<OR, Conjunction>;
Conjunction = Infix<AND, Comparison>;
Comparison = Infix<EQS, Addition>;
Addition = Infix<ADDS, Multiply>;
Multiply = Infix<MULS, Unary>;

Unary: Node<'input> = {
  <l:Unary> <o:POW> <r:Die> => Node::Op(Box::new(l), o, Box::new(r)),
  <o:ADDS> <r:Die> => Node::Unary(o, Box::new(r)),
  Die,
}

Die: Node<'input> = {
  <l:Die> <o:DIE> <r:Atom> => Node::Op(Box::new(l), o, Box::new(r)),
  <o:DIE> <r:Atom> => Node::Unary(o, Box::new(r)),
  Atom,
}

Atom: Node<'input> = {
  <l:LPAREN> <e:Expr> <r:RPAREN> => Node::Group(l, Box::new(e), r),
  Identifier,
  Literal,
}

Identifier: Node<'input> = {
  <s:ID> => Node::Id(s),
}

Literal: Node<'input> = {
  <i:INT> => Node::Int(i),
}

//

EQS: Token<'input> = {
  EQ,
  NE,
  LT,
  LE,
  GT,
  GE,
}

ADDS: Token<'input> = {
  ADD,
  SUB,
}

MULS: Token<'input> = {
  MOD,
  MUL,
  DIV,
}

extern {
  type Location = usize;
  type Error = LexerError;

  enum Token<'input> {
    DELIM => Token::DELIM,
    OR => Token::OR,
    AND => Token::AND,
    EQ => Token::EQ,
    NE => Token::NE,
    LT => Token::LT,
    LE => Token::LE,
    GT => Token::GT,
    GE => Token::GE,
    ADD => Token::ADD,
    SUB => Token::SUB,
    MOD => Token::MOD,
    MUL => Token::MUL,
    DIV => Token::DIV,
    POW => Token::POW,
    DIE => Token::DIE,
    LPAREN => Token::LPAREN,
    RPAREN => Token::RPAREN,
    INT => Token::Int(<i32>),
    ID => Token::Id(<&'input str>),
  }
}
