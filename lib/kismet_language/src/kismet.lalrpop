use super::ast::Node;
use super::lexer::LexerError;
use super::token::Token;
use super::types::Integer;

grammar<'input>;

pub Kismet: Node<'input> = {
  Stmts,
}

Stmts: Node<'input> = {
  Join<DELIM, Stmt> => Node::Stmts(<>),
}

Stmt: Node<'input> = {
  Expr,
}

Expr: Node<'input> = {
  Disjunction,
}

Disjunction = Infix<OR, Conjunction>;
Conjunction = Infix<AND, Comparison>;
Comparison = Infix<EQS, Addition>;
Addition = Infix<ADDS, Multiply>;
Multiply = Infix<MULS, Unary>;

Unary: Node<'input> = {
  <l:Unary> <o:POW> <r:Die> => Node::Op(Box::new(l), o, Box::new(r)),
  <o:ADDS> <r:Die> => Node::Unary(o, Box::new(r)),
  Die,
}

Die: Node<'input> = {
  <l:Die> <o:DIE> <r:Atom> => Node::Op(Box::new(l), o, Box::new(r)),
  <o:DIE> <r:Atom> => Node::Unary(o, Box::new(r)),
  Atom,
}

Atom: Node<'input> = {
  Enclosure,
  Identifier,
  Literal,
}

Enclosure: Node<'input> = {
  LPAREN <JoinPlus<COMMA, Expr>> RPAREN => Node::Tuple(<>),
  <l:LPAREN> <e:Expr> <r:RPAREN> => Node::Enclosure(l, Box::new(e), r),
  LPAREN RPAREN => Node::Tuple(vec![]),
}

Identifier: Node<'input> = {
  ID => Node::Id(<>),
}

Literal: Node<'input> = {
  STRING => Node::String(<>),
  INT => Node::Integer(<>),
}

// Tokens

EQS: Token<'input> = {
  EQ,
  NE,
  LT,
  LE,
  GT,
  GE,
}

ADDS: Token<'input> = {
  ADD,
  SUB,
}

MULS: Token<'input> = {
  MOD,
  MUL,
  DIV,
}

extern {
  type Location = usize;
  type Error = LexerError;

  enum Token<'input> {
    DELIM => Token::DELIM,
    COMMA => Token::COMMA,
    OR => Token::OR,
    AND => Token::AND,
    EQ => Token::EQ,
    NE => Token::NE,
    LT => Token::LT,
    LE => Token::LE,
    GT => Token::GT,
    GE => Token::GE,
    ADD => Token::ADD,
    SUB => Token::SUB,
    MOD => Token::MOD,
    MUL => Token::MUL,
    DIV => Token::DIV,
    POW => Token::POW,
    DIE => Token::DIE,
    LPAREN => Token::LPAREN,
    RPAREN => Token::RPAREN,
    STRING => Token::String(<String>),
    INT => Token::Integer(<Integer>),
    ID => Token::Id(<&'input str>),
  }
}

// Macros

Join<Delim, Child>: Vec<Node<'input>> = {
  <mut v:(<Child> Delim)*> <e:Child?> => match e {
    None => v,
    Some(e) => { v.push(e); v }
  },
}

JoinPlus<Delim, Child>: Vec<Node<'input>> = {
  <mut v:(<Child> Delim)+> <e:Child?> => match e {
    None => v,
    Some(e) => { v.push(e); v }
  },
}

Infix<Op, Next>: Node<'input> = {
  <l:Infix<Op, Next>> <o:Op> <r:Next> => Node::Op(Box::new(l), o, Box::new(r)),
  Next
}