use std::str::FromStr;

use lalrpop_util::ParseError;

use super::ast::{Node, Sym};

grammar;

pub Kismet: Node = {
  Expr
}

Expr: Node = {
  Disjunction,
}

Disjunction: Node = {
  <l:Disjunction> <o:OpOr> <r:Conjunction> => Node::Op(Box::new(l), o, Box::new(r)),
  Conjunction,
}

Conjunction: Node = {
  <l:Conjunction> <o:OpAnd> <r:Comparison> => Node::Op(Box::new(l), o, Box::new(r)),
  Comparison,
}

Comparison: Node = {
  <l:Comparison> <o:OpEq> <r:Addition> => Node::Op(Box::new(l), o, Box::new(r)),
  Addition,
}

Addition: Node = {
  <l:Addition> <o:OpAdd> <r:Multiply> => Node::Op(Box::new(l), o, Box::new(r)),
  Multiply,
}

Multiply: Node = {
  <l:Multiply> <o:OpMul> <r:Unary> => Node::Op(Box::new(l), o, Box::new(r)),
  Unary,
}

Unary: Node = {
  <l:Unary> <o:OpPow> <r:Die> => Node::Op(Box::new(l), o, Box::new(r)),
  <o:OpAdd> <r:Die> => Node::Unary(o, Box::new(r)),
  Die,
}

Die: Node = {
  <l:Die> <o:OpDie> <r:Atom> => Node::Op(Box::new(l), o, Box::new(r)),
  <o:OpDie> <r:Atom> => Node::Unary(o, Box::new(r)),
  Atom,
}

Atom: Node = {
  "(" <e:Expr> ")" => Node::Paren(Box::new(e)),
  Literal,
}

Literal: Node = {
  Num,
}

//

OpOr: Sym = {
  r"(?i)or" => Sym::Or,
}

OpAnd: Sym = {
  r"(?i)and" => Sym::And,
}

OpEq: Sym = {
  "==" => Sym::Eq,
  "!=" => Sym::NotEq,
  "<" => Sym::Less,
  "<=" => Sym::LessEq,
  ">" => Sym::Greater,
  ">=" => Sym::GreaterEq,
}

OpAdd: Sym = {
  "+" => Sym::Add,
  "-" => Sym::Sub,
}

OpMul: Sym = {
  "%" => Sym::Mod,
  "*" => Sym::Mul,
  "/" => Sym::Sub,
}

OpPow: Sym = {
  "^" => Sym::Pow,
}

OpDie: Sym = {
  "d" => Sym::Die,
}

Num: Node = {
  <s:r"[0-9]+"> =>? i32::from_str(s)
    .map(|r| Node::Int(r))
    .map_err(|_| ParseError::User{error: "Integer out of range"}),
}
